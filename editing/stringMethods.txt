String Methods & Properties

Much of the following information can be found in further detail at:

http://www.w3schools.com/js/js_string_methods.asp
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String

As we know at this point strings are commonplace in JS and represent a sequence characters. What we need to learn now, is what we can actually do with them and how we can manipulate them. When you create a string literal, ex. var str = "my string", under the hood it is actually doing new String('my string'). String is a global object constructor function, which is used to create strings, and when a string is created it inherits all the methods of String. I realize this is slightly too technical for some at this point, but at least getting acquainted with new terms will be helpful for when we dive in later.

What we want to talk about today is some of those methods and properties, which are a necessity for your toolkit.

There is a 'length' property that returns how many characters are in the string. An empty string will return a length of 0.

	// syntax
	str.length

	// example
	var str = 'monkeys';
	str.length // 7


Methods:

charAt(): returns the specified character from a string. The index starts at 0, and if it is out of range it will return an empty string.

// syntax
str.charAt(index)

// example
var str = 'monkeys';
str.charAt(5) // 'y'

// advanced
str.charAt(str.length - 1) // this will return the last character, 's'


concat(): this function combines the text from one or more strings and returns a new string. Changes to the text in one string do not affect the other string.

// syntax
str.concat(string2, string3[, ..., stringN]) // any number of strings can be passed in as arguments, which will be added to 'str'

// example
var str = "My name is ";
str.concat("Joe", "Schmo"); // My name is Joe Schmo

It is preferred to join strings via the '+' operator, as it is tremendously faster and much more readable. See the performance test: http://jsperf.com/concat-vs-plus-vs-join

"My name is" + "Joe Schmo" // "My name is Joe Schmo"


indexOf(): returns the index of (the position of) the first occurrence of a specified text in a string, starting the search at the beginning or from the optional fromIndex parameter. It will return -1 if the value is not found.

Common use: see if a value exists within a string.

// syntax
str.indexOf(searchValue[, fromIndex])

// example
var str = 'monkeys';
str.indexOf('mon') // 0
str.indexOf('mon', 2) // -1

// note that this is case sensitive
str.indexOf('Mon') // -1

// real world
var monkey = 'howler monkey';
str.indexOf('howler') !== -1 // true. we know we have a howler monkey

// using indexOf to count occurences, from MSDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf
var str = 'To be, or not to be, that is the question.';
var count = 0;
var pos = str.indexOf('e');

while (pos !== -1) {
  count++;
  pos = str.indexOf('e', pos + 1);
}

console.log(count); // 4. pretty slick , right?!











lastIndexOf(): returns the index for the last occurrence of a given search value in a string. This is the same as indexOf() but starts at the end of a string.

// syntax
str.lastIndexOf(searchValue[, fromIndex])

// example
var str = 'howler monkeys';
str.lastIndexOf('e') // 11


Here's an easy one for ya.

toLowerCase(): returns the calling string value converted to lowercase.

// syntax
str.toLowerCase();

As you might have guessed, this will return 'str' in lower case form. It will not affect the original value. Let's say we had an input that took in a name, and did something with it regardless of case. There also might be times we would want to store everything in lower case. These are cases for '.toLowerCase()'.

// example
var str = 'John Deer';
str.toLowerCase(); // 'john deer'



Naturally, you might not be surprised that there is also an upper case method:

toUpperCase(): returns the calling string value converted to uppercase.

// syntax
str.toUpperCase()

This will return 'str' in upper case form. It will not affect the original value.

// example
var str = 'John Deer';
str.toUpperCase(); // 'JOHN DEER'



trim(): returns the string with whitespace removed from both ends. It does not affect the string itself. Whitespace in this context is all the whitespace characters (space, tab, no-break space, etc.) and all the line terminator characters (LF, CR, etc.).

// syntax
str.trim();

Commonly trim will be used in username/password input fields to remove trailing whitespace that is not acceptable and often unintentional by the user.

// example
var str = '  hello sir '
str.trim(); // 'hello sir' ... spaces are removed from ends only




slice(): extracts a section of a string and returns a new string. Changes in one string do not affect the other string. It will extract up to, but not including, the end slice.

// syntax
str.slice(beginSlice[, endSlice])

// parameters
beginSlice: The zero-based index at which to begin extraction. If negative, it is treated as sourceLength + beginSlice where sourceLength is the length of the string (for example, if beginSlice is -3 it is treated as sourceLength - 3).

endSlice: Optional. The zero-based index at which to end extraction. If omitted, slice() extracts to the end of the string. If negative, it is treated as sourceLength + endSlice where sourceLength is the length of the string (for example, if endSlice is -3 it is treated as sourceLength - 3).


// example
str.slice(1, 4) // extracts the second character through the fourth character (characters indexed 1, 2, and 3).

As an example, str.slice(2, -1) extracts the third character through the second to last character in the string.


// lets use slice to create us a new string
var str = 'Portland is a cool beans place to be.';
var str2 = str.slice(0, 8); // Portland

What happened here is that we started at the 0 index of str, which is the first character, and then extracted 8 characters from that point on and stored them in the variable str2. Let's see what happens if we omit the endSlice parameter
str2 = str.slice(8) // ' is a cool beans place to be.'

We can see that the 8th index was the space between 'Portland' and 'is' and that it extracted everything from that point to the end of the string, including the space. Let's try negative values now.

var str = 'I like to eat burritos.';
var str2 = str.slice(-9) // 'burritos.' Starting with the last index count back 9
var str2 = str.slice(-9, -1); // 'burritos' ... notice the period was trimmed. Be careful. Logically one might think that -1 is the last index value, but it's actually the second to last. It goes backwards one index from last index. starting at 9 indexes from the end, go til one index from end.


substr(): returns the characters in a string beginning at the specified location through the specified number of characters.

// syntax
str.substr(start[, length])

// parameters
start: Location at which to begin extracting characters. If a negative number is given, it is treated as strLength + start where strLength is the length of the string (for example, if start is -3 it is treated as strLength - 3.)

length: Optional. The number of characters to extract.

We can virtually do the same here with substr() as we did with slice().
var str = 'Portland is a cool beans place to be.';
var str2 = str.substr(0, 8); // Portland

str2 = str.substr(8); // ' is a cool beans place to be.'

var str = 'I like to eat burritos.';
var str2 = str.substr(-9); // 'burritos.'
var str2 = str.substr(-9, -1); // ''. empty string

The reason the last one is an emptry string is because we are not extracting to an index, but rather a total count of characters. Here we can really understand the slight different way of thinking when using substr(). substr() extracts a length of characters by a given length value, where slice() extracts a length of characters given by indices.


substring() method returns a subset of a string between one index and another, or through the end of the string.

// syntax 
str.substring(indexStart[, indexEnd])

indexStart: An integer between 0 and the length of the string, specifying the offset into the string of the first character to include in the returned substring.

indexEnd: Optional. An integer between 0 and the length of the string, which specifies the offset into the string of the first character not to include in the returned substring.

var str = 'Portland is a cool beans place to be.';
var str2 = str.substring(0, 8); // Portland

str2 = str.substring(8); // ' is a cool beans place to be.'

var str = 'I like to eat burritos.';
var str2 = str.substring(-9); // 'I like to eat burritos.'
var str2 = str.substring(-9, -1); // ''. empty string

// using .length property
str2 = str.substring(str.length - 9) // 'burritos.'


So, what gives?! Talk about how substr, substring, and split, and the caveats. http://www.bennadel.com/blog/2159-using-slice-substring-and-substr-in-javascript.htm
















search(): executes a search for a match between a regular expression and this String object. If successful it returns the index of the first match of the regular expression inside the string. Otherwise, it returns -1.

// syntax
search(regex)


Talk about how match() could be used for more info, but search is faster.



The replace() method returns a new string with some or all matches of a pattern replaced by a replacement. The pattern can be a string or a RegExp, and the replacement can be a string or a function to be called for each match.




I'm leaving replace blank for now. I think replace and match should be talked about later because they are a bit more complicated and deal with regex, though replace does work with strings, we would be remiss to not go deeper into this one.


The following deal with regular expressions. A regular expression (regex) is an sequence of characters that defines a search pattern. Regular expressions are used to perform pattern-matching and "search-and-replace" functions on text.




match(): retrieves the matches when matching a string against a regular expression, and returns them in an array or null if there were no matches. We have not covered regular expressions yet, and will have to do a dive later on. They can be complicated.

// syntax
str.match(regexp)


See MSDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match

In the following example, match() is used to find 'Chapter' followed by 1 or more numeric characters followed by a decimal point and numeric character 0 or more times. The regular expression includes the i flag so that case will be ignored.

var str = 'For more information, see Chapter 3.4.5.1';
var re = /(chapter \d+(\.\d)*)/i;
var found = str.match(re);

console.log(found);

// logs ['Chapter 3.4.5.1', 'Chapter 3.4.5.1', '.1']

// 'Chapter 3.4.5.1' is the first match and the first value 
// remembered from `(Chapter \d+(\.\d)*)`.

// '.1' is the last value remembered from `(\.\d)`.



The following example demonstrates the use of the global and ignore case flags with match(). All letters A through E and a through e are returned, each its own element in the array.

var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var regexp = /[A-E]/gi;
var matches_array = str.match(regexp);

console.log(matches_array);
// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']









There are many more, some deprecated, and some part of ECMA6, that I encourage you to continue further research on your own.